{
  const JUNCTION_OPERATOR = {
    '&': 'conjunction',
    '|': 'disjunction',
    'âŠ•': 'exclusive_disjunction',
  };
  function join(first, rest) {
    if (rest.length === 0) return first;
    const [operator, next] = rest.shift();
    switch (operator) {
      case '&':
      case '|':
      case 'âŠ•':
        const clauses = [first, next];
        while (rest.length > 0 && rest[0][0] === operator) {
          clauses.push(rest.shift());
        }
        if (rest.length > 0) {
          clauses.push(join(rest.shift(), rest));
        }
        return {
          type: JUNCTION_OPERATOR[operator],
          clauses: clauses,
        };
      case "!=":
      case ">=":
      case "<=":
      case '=':
      case '>':
      case '<':
        return {
          type: 'comparison',
          operator,
          left: first,
          right: join(next, rest),
        };
      case '+':
      case '-':
      case '*':
      case '/':
      case '^':
        return {
          type: 'binary_operation',
          operator,
          left: first,
          right: join(next, rest),
        };
    }
    throw new Exception(`unknown operator ${operator}`);
  }
  function flatten(arr) {
    return arr.reduce((acc, cur) => acc.concat(Array.isArray(cur) ? flatten(cur) : cur), []);
  }
  function parseNumber(n) {
    return parseFloat(flatten(n).filter(d => d).join(''));
  }
  const BUILT_IN_FUNCTIONS = ["floor", "ceil", "min", "max", "sum", "count", "Pr"];
  function functionOrFact(name, args) {
    if (BUILT_IN_FUNCTIONS.indexOf(name) !== -1) {
      return { type: 'function', function: name, arguments: args };
    } else {
      return { type: 'fact', table: name, fields: args };
    }
  }
}

statements
  = statement+

statement
  = comment:comment "\n"? { return comment }
  / inference:inference "." { return inference }
  / claim:claim "." { return claim }
  / fn:function "." { return fn }
  / roll:rolling "." { return roll}
  / query:query "." { return query }
  / __ { return null }

comment
  = "//" comment:[^\n]* { return { type: 'comment', value: comment.join('').trim() } }
  / "/*" comment:(!"*/" .)* "*/" { return { type: 'comment', value: comment.flat().join('').trim() }}

inference
  = left:function _ ":-" _ right:expr { return { type: 'inference', left, right } }

claim
  = "âˆ´" _ clause:expr { return { type: 'claim', clause: clause } }

rolling
  = "ðŸŽ²" _ clause:expr { return { type: 'rolling', clause: clause } }

query
  = "?" _ query:expr { return { type: 'query', clause: query } }

expr
  = first:term rest:next_expr* { return join(first, rest) }
  / "(" _ first:expr _ ")" rest:next_expr* { return join(first, rest) }

next_expr
  = _ operator:operator _ "(" _ expr:expr _ ")" { return [operator, expr] }
  / _ operator:operator _ expr:expr { return [operator, expr] }

term
  = function
  / string
  / variable
  / roll
  / number

function
  = name:([A-Za-z_]+) "(" _ args:arguments _ ")" { return functionOrFact(name.join(''), args.arguments) }
  / "~" fn:function { return { ...fn, negative: true } }

arguments
  = first:expr rest:nextargs* { return { type: 'arguments', arguments: [first].concat(rest) } }

nextargs
  = _ "," _ expr:expr { return expr }

operator
  = op:("!=" / ">=" / "<=") { return op }
  / op:[=!><&|âŠ•+\-*/] { return op }

string
  = name:([A-Z][A-Za-z_]+) { return { type: 'string', value: name[0] + name[1].join('') } }

variable
  = name:([a-z_]+) { return { type: 'variable', value: name.join('') } }
  / "?" { return { type: 'variable', value: '?' } }

roll
  = count:([0-9]+) "d" die:([0-9]+) modifier:([+-][0-9]+)? { return { type: 'roll', count: parseInt(count.join('')), die: parseInt(die.join('')), modifier: modifier ? parseInt(modifier.join('')) : 0 } }

number
  = number:([-]?[0-9]+([.][0-9]+)?) { return { type: 'number', value: parseNumber(number) } }

_  = [ \t\r\n]*

__ = [ \t\r\n]+